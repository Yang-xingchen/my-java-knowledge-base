> 内容以MySql InnoDB为主，其他情况会特殊说明

# 类型

## B-Tree
使用`B-Tree`存储索引数据。

支持的查询类型:
- 全值匹配，如`key(a); a=1`
- 匹配最左前缀，如`key(a,b); a=1`
- 匹配列前缀，如`key(a); a like 'a%'`
- 精准匹配某列并范围匹配另外一列, 如`key(a,b); a=1 and b > 0`
- 只访问索引的查询(覆盖索引)，如`key(a,b); SELECT a,b FROM t WHERE a=1`

> 也可用于排序

在MySql8.0.1后，引入了索引跳跃扫描，可在特定情况下将查询拆分成多个查询UNION，使其可使用索引。

如: `key(a,b)`
```
SELECT * FROM t WHERE a in (1,2,3) AND b>1
```
优化器可能拆分成:
```
SELECT * FROM t WHERE a=1 AND b>1
UNION
SELECT * FROM t WHERE a=2 AND b>1
UNION
SELECT * FROM t WHERE a=3 AND b>1
```

## 哈希索引
使用`Hash表`存储索引数据（哈希冲突采用拉链法解决）。该方法存储空间占用较小，查询效率较高，但限制也大。

支持的查询类型:
- 全值匹配，如`key(a); a=1`

## _空间数据索引(R-Tree)_
> TODO

## _全文索引_
> TODO

# 使用技巧
## 独立的列
即查询不为表达式的一部分，如以下**反例**:
```
SELECT * FROM t WHERE a+1=1
```
> [!TIP]
> 在MySql8.0后，支持函数索引，可在创建索引的时候指定函数，这样在使用索引时可使用该函数

## 前缀索引
当索引很长的字符列时，可只使用其开始的一部分字符（多列索引时必须为最后一列）以减少空间占用。

该方法无法作`ORDER BY`或`GROUP BY`，也无法作覆盖扫描。

> [!TIP]
> 如果需要对类似于手机号、同个城市的身份证号之类的前面大部分字符相同的列作前缀索引，多存储一列值为该列数据的反转字符，对该反转字符作前缀索引

## 多列索引
当查询涉及多列`AND`查询时，对所有列创建一个联合索引。

如果对每个列创建单独索引，可能导致只使用其中一个索引或使用多个索引后再进行索引合并，其性能较差（部分时候甚至差过全表扫描）

## 选择合适的列顺序
将多个精准查询的列中选择性最高的列放在索引前面。

## 聚簇索引
使用的查询列作为主键存储，这样能极大的加快速度。

但需要注意以下几点:
- 插入速度严重依赖插入顺序
- 更新代价很高，更新主键会强制移动该数据
- 插入新行或更新导致移动时，可能会产生页分裂，导致占用更多磁盘空间
- 当随机插入频繁时，可能导致数据不连续，最终导致全表查询较慢
- 非聚簇索引可能占用更大磁盘空间，因为其叶节点会包含主键列

## 覆盖索引
当索引覆盖了查询所需的列时，可避免回表查询，提高查询速率。该方法会导致索引占用空间增加。

以下情况**无法使用**到覆盖索引:
- `SELECT *`
- 哈希索引等不存储具体值

## 使用索引进行排序
- 当索引的列顺序与`ORDER BY`的顺序完全一致，且排序方向一致时，MySql可使用索引对结果进行排序。
- 当需要关联多张表时，只有当`ORDER BY`引用的字段全部为第一个表时，才能使用索引做排序。
- 需要满足索引的最左前缀要求

当最左列为常量时可在不满足最左前缀要求`key(a,b)`
```
SELECT * FROM t WHERE a=1 ORDER BY b
```

## 索引下推
在MySql5.6后，当不满足最左查询条件时，也可使用索引进行索引下推查询。

如: `key(a,b，c)`
```
SELECT a,b,c FROM t WHERE a=1 AND b>1 AND c>1
```
若不使用索引下推，则使用该索引查询`a=1`的数据后回表查询。

若使用索引下推，则使用索引中记录的b和c的值进行查询后返回数据。此时`EXPLAIN`中`extra`内容为`Using index condition`

## 使用区分度不高的列
当区分度不高时，通常不作为索引，但有以下特例:
- 可选值较少且需做覆盖索引，如性别字段。该情况下查询时需添加`sex IN ('f','m')`以使用该索引
- 比例较大，如状态字段中`INIT:SUCCESS=1:99`时，大部分查询查询`INIT`的数据可添加该索引

## 避免重复索引
索引会占用存储空间，且会增加写数据开销，故索引数量并不是越多越好。

以下**反例**:
1. `key(ID)`: 主键默认已做索引
2. `key(a,ID)`: 索引默认存储主键
3. `key(a); key(a,b)`: `key(a,b)`已包含`key(a)`
