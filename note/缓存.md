# 类型
## 本地缓存
数据缓存在应用进程中(多个进程数据不共享)，读写速度小于1ms。

产品:
- [Caffeine](../frame/caffeine)
- Guava

## 分布式缓存
数据缓存在独立的进程中(多个进程数据共享)，读写速度小于10ms。

产品:
- [Redis](../middleware/redis)
- Memcached

# 注意事项
## 数据一致性
数据库数据与缓存数据不同导致业务异常。

### 数据更新方案(分布式缓存)
1. 先更新数据库，后删除缓存: 并发不大可用，可能导致短时间缓存不一致
    - 不先删除缓存原因: 避免因为删除缓存而未更新数据库的时刻有访问查询，因读取数据库旧值写入缓存导致长时间数据不一致
2. 延时双删(先删除缓存，后更新数据库，延迟一段时间后再次删除缓存): 可处理大多数场景，相对复杂
    - 先删缓存原因: 即便数据库更新失败也只是导致一次缓存生效，不会导致数据不一致
    - 不先更新数据库原因: 避免因为删除缓存失败而导致数据不一致
    - 延迟一段时间再次删除缓存原因: 避免删除缓存后，更新数据库前有其他请求缓存旧值，所以等待一段时间等其他请求完成缓存后再次删除。

## 缓存穿透
当访问不存在的数据时，缓存中也不存在，导致每次程序都需要回表查询。

### 解决方案
1. 缓存空值
2. 布尔过滤器

## 缓存击穿
当热点key过期时，大量并发请求同时访问服务器直接查询查询数据库。

### 解决方案
1. 自动刷新缓存: 在过期前提前刷新缓存
2. 分布式锁

## 缓存雪崩
大量缓存同时过期或缓存服务器宕机，所有请求直接访问数据库。

### 解决方案
1. 随机过期时间(处理同时过期)
2. 集群(处理服务器宕机)

# Spring
spring有缓存相关处理框架[spring cache](../frame/spring-cache), 可适配使用缓存