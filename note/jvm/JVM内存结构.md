# 线程计数器
Program Counter Register, 线程计数器。线程独有的只读存储器，记录该线程执行的字节码指令地址。用于控制程序分支、循环、跳转、异常处理、线程恢复等基础功能。

该区域不会产生OOM。

# Java虚拟机栈
Java Virtual Machine Stack, Java虚拟机栈。线程独有的存储器，存储方法执行的局部变量表、操作数栈、动态连接、方法出入口等信息。当调用方法时入栈一个栈帧，存储方法运行数据，退出方法时出栈该栈帧。

当栈深度大于虚拟机允许的最大深度，会产生`StackOverflowError`异常。

## 局部变量表
包含多个槽(Slot)，在编译器即可根据局部变量数量确定数量(记录于`max_locals`，每个`long`和`double`占两个槽，`boolean`,`byte`,`char`,`short`,`int`,`folat`占一个槽，可重用)。
用以存储局部变量，若为实例方法，第一个槽默认为`this`。

## 操作数栈
为一个栈结构的数据结构，在编译器即可确定最大深度(记录于`max_stacks`，每个`long`和`double`占两个槽，`boolean`,`byte`,`char`,`short`,`int`,`folat`占一个槽)。
在方法开始的时候，栈为空的，根据指令内容对栈进行操作

## 动态链接
支持动态连接功能。在运行期将符号引用转化为直接引用。

## 方法返回地址
正常`return`或异常`throw`结束方法后，程序要返回的地址

## 其他信息
非JVM规范里的描述信息

# 本地方法栈
Native Method Stack, 本地方法栈。与Java虚拟机栈类似，但执行的是本地方法。部分虚拟机将该区域和Java虚拟机栈合并。

会产生`StackOverflowError`异常。

# Java堆
Java Heap, Java堆。线程共享的存储器。几乎所有的对象实例和数组在该区域分配(栈上分配、标量替换等优化手段可分配到栈上)。

当无法完成实例分配，且无法扩展内存时，产生`OutOfMemoryError`异常。

## 堆内存布局
Java堆由新生代(Young Generation)和老年代(Old Generation)构成。两者独立进行GC。

可有两种分布方式:
- 连续分布: 新生代和老年代分别为连续的内存空间，默认新生代:老年代空间占比为`1:2`。新生代又分为`from survivor`(默认10%), `to survivor`(默认10%), `eden`(默认80%)。
- Region: 将内存区域划分为不同的`Region`，每个`Region`分别属于新生代或老年代。

## GC
见[GC.md](GC.md)

## 对象内存分布
1. 对象头(Header)
   1. Mark Word: 存储对象运行时信息，占用32bit或64bit。
   2. 类型指针: 对象的类型元数据的指针及数组长度
2. 实例数据(Instance Data): 对象字段内容，即程序中读写的数据，包括父类字段和当前类字段
3. 对齐填充(Padding): 填充对象长度至8字节的整数倍，没有实际意义，不一定存在

# 方法区
Method Area, 方法区。线程共享的存储器，存储已被加载的类型信息、常量、静态变量、即时编译后的代码缓存等数据。

当无法完成内存分配需求时，产生`OutOfMemoryError`异常。

# 运行时常量池
Runtime Constant Pool, 运行时常量池。属于方法区的一部分。存储编译器生成的字面量和符号引用(在类加载后进入运行时常量池)、运行器手动放入的常量，如`String#intern()`。
根据规范，字符串常量池属于运行时常量池，但在`JDK1.7`后移动到了Java堆。

当无法完成内存分配需求时，产生`OutOfMemoryError`异常。

# _直接内存_
Direct Memory, 直接内存，也称堆外内存。该区域并非虚拟机运行时内存区域的一部分，也非规范定义的区域，该区域不受GC管理。存储通过`NIO`或`Unsafe`创建。

当使用内存大于物理内存时，产生`OutOfMemoryError`异常。
