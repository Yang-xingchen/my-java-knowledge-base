# 编译器
- 前端编译器: 把`.java`文件编译成`.class`文件。如: `javac`
- 即时编译器(JIT, Just In Time Compiler): 运行期把字节码编译为本地机器码。如: `C1`、`C2`
- 提前编译器(AOT, Ahead Of Time Compiler): 直接把程序编译为目标机器指令集的代码

# 前端编译器(Javac)
JDK9后处于`jdk.compiler`模块(入口为`com.sun.tools.javac.Main`)

流程:
1. 准备: 初始化注解处理器
2. 解析与填充符号表
   1. 词法、语法分析。将源代码字符流转变为标记集合，构造抽象语法树(AST)
   2. 填充符号表。产生符号地址和符号信息，添加默认构造方法`<init>()`及静态方法`<clinit>()`
3. 执行注解处理器 [processor](../../base/src/main/java/compiler/processor)
4. 分析与字节码生成
   1. 标注检查: 检查使用的变量是否声明、变量类型是否匹配、常量折叠等
   2. 数据流及控制流分析: 检查变量使用前是否赋值、方法返回路径是否都有返回值。受检查异常是否都处理等
   3. 解语法糖
   4. 字节码生成

# 即时编译器
JVM运行期间默认采用解释模式与编译模式混合运行。虚拟机通常包含客户端编译器(C1)和服务端编译器(C2)

## 分层编译
根据编译器编译、优化规模和耗时，分为不同编译层次:
1. 0层: 纯解释执行，不开启性能监控
2. 1层: 客户端编译为本地代码，进行简单稳定优化，不开启性能监控
3. 2层: 客户端编译为本地代码，开启方法及回边次数统计等有限的监控
4. 3层: 客户端编译为本地代码，开启全部性能监控
5. 4层: 服务端编译为本地代码，提供更多更激进的优化

## 热点检测
1. 采样: 周期检测栈顶方法，若某方法经常出现在栈顶，即为热点方法
2. 计数器: 对方法及回边进行计数统计，当计数超过某个阈值，则为热点方法
   1. 方法计数
      1. 使用`-XX:CompileThreshold`设置阈值，默认客户端1500，服务端10000
      2. 默认开启热度衰减(通过`+XX:-UseCounterDecay`关闭): 当一段时间内的计数不足阈值时，计数器计数减少一半
   2. 回边计数
      1. 阈值为(方法计数器阈值`-XX:CompileThreshold`，OSR比率`-XX:OnStackReplacePercentage`, 解释器监控比率`-XX:InterpreterProfilePercentage`): 
         - 客户端: 方法计数器阈值 * OSR比率 / 100
         - 服务端: 方法计数器阈值 * (OSR比率 - 解释器监控比率) / 100
      2. 不开启热度衰减

## 编译优化
在编译期间会进行一系列优化操作，提高运行性能。

优化列表: https://wiki.openjdk.org/display/HotSpot/PerformanceTacticIndex

### 方法内联
将方法内容直接插入到调用代码中，具体流程为:
1. 确认是否为非虚方法，若为非虚方法，直接内联。
2. 若为虚方法，使用CHA(类型继承关系分析，Class Hierarchy Analysis)判断是否有多个版本可供选择
   1. 若只有一个版本，进行守护内联，并准备逃生门(即情况发生变更的退路)。当虚拟机加载了导致继承关系发生变化的新类，放弃该优化，退回到解释模式运行
   2. 若有多个版本，进行内联缓存。即判断方法接收者的版本信息，内联不同的方法

### 逃逸分析
分析对象的作用范围，分为以下状态:
- 从不逃逸: 对象作用域仅在当前方法
- 参数逃逸: 作为方法参数传递到其他方法
- 全局逃逸: 被外部线程访问、存储于静态字段，通过返回值返回

后续可进行的优化:

| 名称 | 从不逃逸 | 参数逃逸 | 全局逃逸 | 说明 |
|---|---|---|---|---|
| 栈上分配 | Y | Y | N | 在栈上分配该对象的内存，这样就可以通过出栈回收资源 |
| 标量替换 | Y | N | N | 将对象拆解为该对象的成员变量，直接对该变量进行操作 |
| 同步消除 | Y | Y | N | 若确定变量不会被其他线程访问，将线程同步相关操作移除 |

# 提前编译器
直接把程序编译为目标机器指令集的代码，AOT有两种类型:
1. 在运行前就将程序代码编译为机器码，打破平台无关性
2. 把运行期的JIT编译结果保存下来，供后续执行(程序重启)或其他程序执行(公共类库)时使用