# 加载
当满足以下任意条件时，类会被加载:
- 遇到`new`, `getstatic`, `putstatic`, `invokestatic`这四条指令
  - 使用`new`实例化
  - 读取或设置静态字段(`final`修饰，在编译期定义在属性表的`ConstantValue`类型除外)
  - 调用静态方法
- 使用反射进行访问
- 初始化类时，该类父类未被初始化，则初始化该父类
- JVM启动，自动加载部分类，如主类
- `MethodHandle`解析结果为`REF_getStatic`, `REF_putStatic`, `REF_invokeStatic`, `REF_newInvokeSpecial`类型的方法句柄时，初始化对应类
- 包含了默认方法的接口的实现类初始化时，该接口未被初始化，则初始化该接口

经典不初始化情况:
1. 通过子类调用父类静态字段
2. 数组定义(会初始化对应的数组类，但原始类不会初始化)
3. 使用定义在属性表的`ConstantValue`类型的常量

加载过程:
1. 加载
   1. 通过全限定名获取定义该类的二进制字节流
   2. 将这个字节流转换为方法区的运行时数据结构
   3. 生成`java.lang.Class`实例，作为方法区的相关数据的访问入口
2. 链接
   1. 验证: 确保字节流信息符合JVM规范
      1. 文件格式验证，符合[类文件结构.md](类文件结构.md)
      2. 元数据验证，保证符合Java语言规范
         - 验证父类(是否存在、是否非`final`)
         - 若该类不是抽象类，是否实现了所有方法
         - 是否出现于父类矛盾的方法
         - ...
      3. 字节码验证，保证代码内容正确
      4. 符号引用验证，验证符号引用 
         - 是否找到该表示的类及对应其方法和字段
         - 是否运行该类访问该方法及字段
         - ...
   2. 准备: 分配类变量内存(设置零值)，设置常量的默认值(仅常量定义在属性表的`ConstantValue`类型)
   3. 解析: 把符号引用替换为直接引用
      1. 类或接口: 将类或接口的符号引用解析为直接引用，可能递归加载类
      2. 字段: 将字段的符号引用解析为直接引用，会递归访问父类
      3. 方法: 将方法的符号引用解析为直接引用，若方法所属类是接口，抛出`java.lang.IncompatibleClassChangeError`，会递归访问父类
      4. 接口方法: 将接口方法的符号引用解析为直接引用，若方法所属类不是接口，抛出`java.lang.IncompatibleClassChangeError`，会递归访问父接口
3. 初始化，即执行`<client>()`方法(该方法由`javac`自动生成，由对类变量的赋值操作及`static{}`代码块组合生成)

# 使用
- [创建类对象](../../base/src/main/java/other/CreateEntry.java)
- 获取类信息
- ...

# 卸载
当满足以下全部条件时，类会被卸载:
1. 该类所有实例已被回收(即无法通过`.getClass()`获取)
2. 该类的`ClassLoader`已被回收
3. 该类对应的Class对象没有被引用