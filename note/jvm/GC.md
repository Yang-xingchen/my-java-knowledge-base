# 连续内存分布
将堆内存划分为连续的两部分内存: 新生代(Young Generation)和老年代(Old Generation)，两部分内存采用不同的GC算法管理。

搭配支持:

| | Serial | ParNew | Parallel Scavenge |
|---|---|---|---|
| Serial Old | 支持 | JDK9后不支持 | 支持 |
| CMS | JDK9后不支持 | 支持 | 不支持 |
| Parallel Old | 不支持 | 不支持 | 支持 |

## Serial
最基础、最悠久的垃圾收集器。客户端模式默认新生代垃圾收集器。采用标记-复制算法。

优点:
- 简单高效
- 额外内存开销最小
- 没有线程切换开销

缺点:
- 执行时需要暂停用户线程

应用场景:
- 小型程序(单核CPU、小于1G内存)

## ParNew
`Serial`的多线程版本。服务端新生代垃圾收集器。采用标记-复制算法。

优点:
- 多线程搜集数据
- JDK9后`CMS`唯一支持

缺点:
- 执行时需要暂停用户线程
- 单核情况不如`Serial`(超线程也不一定会好)
- JDK9后只支持`CMS`

应用场景:
- 需要使用`CMS`

## Parallel Scavenge
吞吐量优先的垃圾收集器，可控制吞吐量和最大停顿时间偏好。采用标记-复制算法。

优点:
- 可设置最大停顿时间
- 可自动管理新生代各区域比例及晋升规则(需要`-XX:+UseAdaptiveSizePolicy`参数)

缺点:
- 执行时需要暂停用户线程

应用场景:
- 较高优化需求场景

## Serial Old
`Serial`的老年代版本。客户端模式默认老年代代垃圾收集器。采用标记-整理算法。

优点:
- 简单高效
- 额外内存开销最小
- 没有线程切换开销

缺点:
- 执行时需要暂停用户线程
- 无法利用多线程

应用场景:
- 小型程序(单核CPU、小于1G内存)

## CMS
可与用户线程并发执行的垃圾收集器。采用标记-清除算法。

优点:
- 需要暂停用户线程的时间短
- 并发执行标记及清理过程

缺点:
- 对处理器内存资源敏感
- 可能产生浮动垃圾
- 可能产生内存碎片(导致分配大内存时失败而进行碎片合并)

应用场景:
- 中型程序(大于4核、1G~6G内存)

## Parallel Old
`Parallel Scavenge`的老年代版本。采用标记-整理算法。

优点:
- 可与`Parallel Scavenge`配合

缺点:
- 执行时需要暂停用户线程
- 只支持`Parallel Scavenge`

应用场景:
- 需要使用`Parallel Scavenge`

# Region
将整个堆内存划分为多个`Region`，整体采用同一个算法管理

## G1
Garbage-First(G1)，于`JDK 8 Update 40`完成全部功能。`JDK9`下默认服务端垃圾收集器。

G1把内存区域划分为多个大小相等的独立`Region`，大小可设置为`1MB~32MB`中`2^n`大小，每个`Region`分为不同类型:
- Eden: 新生代区域，用于分配新对象内存
- Survivor: 新生代区域，用于分配新对象内存及存储垃圾回收后未回收的对象
- 老年代: 老年代区域，用于存储长期未回收的对象
- Humongous: 大对象区域，存储大于单个`Region`区域一半的对象，若对象大于单个`Region`，则使用多个连续的`Humongous`存储

垃圾回收时优先选择回收价值大的`Region`，并非回收全部`Region`。

优点:
- 需要暂停用户线程的时间短
- 并发执行标记及清理过程
- 可指定最大停顿时间
- 不会产生内存碎片

缺点:
- 内存占用很大(甚至大于堆内存的20%)

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`JDK9`及以上场景

## Shenandoah
`OpenJDK 12`支持的垃圾收集器(`Oracle JDK`不支持该垃圾回收器)。

与`G1`区别:
1. 支持并发整理，可以与用户线程并行
2. 默认不分代
3. 使用连接矩阵(Connection Matrix)而非记忆集
4. 使用转发指针+读屏障实现并发整理

优点:
- 需要暂停用户线程的时间极短
- 并发执行标记及清理过程
- 可指定最大停顿时间
- 不会产生内存碎片

缺点:
- 内存占用较大
- 使用读屏障增加对象访问开销(只有一条指令，但对象访问频率极高以至于不可忽视)
- 只有`OpenJDK 12`及以上版本支持

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`OpenJDK 12`及以上版本

## ZGC
Z Garbage Collector，与`JDK11`开始支持。

与`G1`区别:
1. 不分代
2. `Region`大小不固定，分为: 小型(`2MB`, 放置小于`256KB`的对象)、中型(`32MB`, 放置`256KB`~`4MB`的对象)、大型(`2MB`的整数倍，放置大于`4MB`的对象，且每个`Region`仅放置一个)
3. 不使用记忆集
4. 使用染色指针+读屏障实现并发整理

优点:
- 需要暂停用户线程的时间极短
- 吞吐量大

缺点:
- 仅支持`Linux 64位`系统
- 使用`JDK 11`及以上版本
- 管理内存小于`4TB`
- 对象分配速率不能太高

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`JDK 11`及以上版本+`Linux 64位`系统

# 其他
## Epsilon
不进行垃圾回收的垃圾收集器，仅进行分配，内存分配完成后结束进程。

优点:
- 运行负载极低

缺点:
- 无法进行垃圾回收

应用场景
- 运行时长极短的程序(如执行脚本)