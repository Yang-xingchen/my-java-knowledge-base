# GC Roots
在可达性分析中的起始根对象。
包括:
- 虚拟机栈中引用的对象
- 方法区类静态引用对象
- 方法区常量引用对象
- 本地方法栈中`JNI`引用对象
- 被同步锁持有的对象
- 虚拟机内部引用(如基本数据类型的`Class`对象、类加载器等)
- 虚拟机中的`JMXBean`、`JVNTI`注册的回调，本地代码缓存等
- (部分垃圾回收器)其他区域的对象

# GC算法
- 标记-清除: 标记需要清除的区域后，将该区域对象清除(也可以反过来，标记要保留的区域，将其他区域对象清除)。可能产生内存碎片。
- 标记-复制: 标记存活的对象，将其复制到另外一片未使用的区域。
- 标记-整理: 标记存活的对象，清理非存活对象，并将存活的对象移动到一侧。

# 并发可达性分析
三色标记算法:
将对象标记为三种颜色:
- 白色: 未被GC访问过。在开始阶段，所有对象都是白色，在结束阶段，不可达对象为白色。
- 黑色: 已被访问，且所有引用都被扫描完毕。黑色对象不能直接指向白色对象。
- 灰色: 已被访问，但所有引用未被扫描完毕。

若达成以下条件时，黑色会错误标记成白色:
1. 添加了黑色到白色的引用
2. 删除全部灰色到白色的引用

解决方法:
1. 增量更新: 破坏条件1。当黑色对象添加到白色对象的引用时，记录该对象，在扫描结束后，再次扫描记录的对象。
2. 原始快照(`SATB`): 破坏条件2。当灰色对象删除对白色对象的引用时，记录该对象，在扫描结束后，再次扫描记录的对象。

---
# 连续内存分布
将堆内存划分为连续的两部分内存: 新生代(Young Generation)和老年代(Old Generation)，两部分内存采用不同的GC算法管理。

搭配支持:

| | Serial | ParNew | Parallel Scavenge |
|---|---|---|---|
| Serial Old | 支持 | JDK9后不支持 | 支持 |
| CMS | JDK9后不支持 | 支持 | 不支持 |
| Parallel Old | 不支持 | 不支持 | 支持 |

## Serial
最基础、最悠久的垃圾收集器。客户端模式默认新生代垃圾收集器。

流程:
- 到达检查点后，暂停所有用户线程，单线程采用标记-复制算法进行GC

优点:
- 简单高效
- 额外内存开销最小
- 没有线程切换开销

缺点:
- 执行时需要暂停用户线程

应用场景:
- 小型程序(单核CPU、小于1G内存)

## ParNew
`Serial`的多线程版本。服务端新生代垃圾收集器。

流程:
- 到达检查点后，暂停所有用户线程，多线程采用标记-复制算法进行GC

优点:
- 多线程搜集数据
- JDK9后`CMS`唯一支持

缺点:
- 执行时需要暂停用户线程
- 单核情况不如`Serial`(超线程也不一定会好)
- JDK9后只支持`CMS`

应用场景:
- 需要使用`CMS`

## Parallel Scavenge
吞吐量优先的垃圾收集器，可控制吞吐量和最大停顿时间偏好。

流程:
- 到达检查点后，暂停所有用户线程，多线程采用标记-复制算法进行GC

优点:
- 可设置最大停顿时间
- 可自动管理新生代各区域比例及晋升规则(需要`-XX:+UseAdaptiveSizePolicy`参数)

缺点:
- 执行时需要暂停用户线程

应用场景:
- 较高优化需求场景

## Serial Old
`Serial`的老年代版本。客户端模式默认老年代代垃圾收集器。

流程:
- 到达检查点后，暂停所有用户线程，单线程采用标记-整理算法进行GC

优点:
- 简单高效
- 额外内存开销最小
- 没有线程切换开销

缺点:
- 执行时需要暂停用户线程
- 无法利用多线程

应用场景:
- 小型程序(单核CPU、小于1G内存)

## CMS
可与用户线程并发执行的垃圾收集器。

流程:
1. 初始标记: 到达检查点后，暂停所有用户线程，单线程标记所有`GC Roots`直接关联的对象
2. 并发标记: 与用户线程同步执行，从初始标记得到的对象进行遍历
3. 重新标记: 到达检查点后，暂停所有用户线程，多线程修复增量更新记录下的引用变动对象
4. 并发清理: 删除判断已死亡的对象

优点:
- 需要暂停用户线程的时间短
- 并发执行标记及清理过程

缺点:
- 对处理器内存资源敏感
- 可能产生浮动垃圾
- 可能产生内存碎片(导致分配大内存时失败而进行碎片合并)

应用场景:
- 中型程序(大于4核、1G~6G内存)

## Parallel Old
`Parallel Scavenge`的老年代版本。

流程:
- 到达检查点后，暂停所有用户线程，多线程采用标记-整理算法进行GC

优点:
- 可与`Parallel Scavenge`配合

缺点:
- 执行时需要暂停用户线程
- 只支持`Parallel Scavenge`

应用场景:
- 需要使用`Parallel Scavenge`

# Region
将整个堆内存划分为多个`Region`，整体采用同一个算法管理

## G1
Garbage-First(G1)，于`JDK 8 Update 40`完成全部功能。`JDK9`下默认服务端垃圾收集器。

G1把内存区域划分为多个大小相等的独立`Region`，大小可设置为`1MB~32MB`中`2^n`大小，每个`Region`分为不同类型:
- Eden: 新生代区域，用于分配新对象内存
- Survivor: 新生代区域，用于分配新对象内存及存储垃圾回收后未回收的对象
- 老年代: 老年代区域，用于存储长期未回收的对象
- Humongous: 大对象区域，存储大于单个`Region`区域一半的对象，若对象大于单个`Region`，则使用多个连续的`Humongous`存储

垃圾回收时优先选择回收价值大的`Region`，并非回收全部`Region`。

记忆集: 
- 记忆从非收集区域(其他区域)指向收集区域(该区域)的指针集合。

卡表:
- 记忆集的一种具体实现，记录仅精确到一块内存区域，该区域内存在含有指向收集区域的指针。在`G1`中，每个`Region`维护主机的一个记忆集，卡表本质为哈希表(`key`为其他`Region`的起始地址，`value`为卡表索引号集合)

TAMS指针:
- Top at Mark Start指针，在并发标记阶段新分配的对象都在该指针之上，且默认该对象都是存活的

流程:
1. 初始标记: 到达检查点后，暂停所有用户线程，单线程标记所有`GC Roots`直接关联的对象，并修改`TAMS`指针的值
2. 并发标记: 与用户线程同步执行，从初始标记得到的对象进行遍历，及处理`SATB`记录下的引用变动对象
3. 最终标记: 到达检查点后，暂停所有用户线程，多线程处理并发标记结束后遗留的少量`SATB`记录下的引用变动对象
4. 筛选回收: 继续暂停所有用户线程，多线程统计各`Region`数据，判断需要回收的`Region`，并将其存活对象复制到空`Region`中，然后清理旧`Region`全部空间

优点:
- 需要暂停用户线程的时间短
- 并发执行标记及清理过程
- 可指定最大停顿时间
- 不会产生内存碎片

缺点:
- 内存占用很大(甚至大于堆内存的20%)

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`JDK9`及以上场景

## Shenandoah
`OpenJDK 12`支持的垃圾收集器(`Oracle JDK`不支持该垃圾回收器)。

与`G1`区别:
1. 支持并发整理，可以与用户线程并行
2. 默认不分代
3. 使用连接矩阵(Connection Matrix)而非记忆集
4. 使用转发指针+读屏障实现并发整理

邻接矩阵:
- 采用二维表，当`Region N`存在指向`Region M`的记录时，便在`N`行`M`列添加标记

转发指针:
- 在对象前添加一个指针，默认指向自己，若产生移动，则指向新对象。当访问对象时，需要多一次跳转。若与用户线程产生并发，采用CAS解决对象访问正确性。

流程:
1. 初始标记: 到达检查点后，暂停所有用户线程，单线程标记所有`GC Roots`直接关联的对象，并修改`TAMS`指针的值
2. 并发标记: 与用户线程同步执行，从初始标记得到的对象进行遍历，及处理`SATB`记录下的引用变动对象
3. 最终标记: 到达检查点后，暂停所有用户线程，多线程处理并发标记结束后遗留的少量`SATB`记录下的引用变动对象
4. 并发清理: 与用户线程同步执行，清理整个`Region`都没有存活对象的`Region`
5. 并发回收: 与用户线程同步执行，将回收集内存活的对象复制到其他空`Region`中，采用读屏障及转发指针解决对象访问
6. 初始化引用更新: 暂停所有用户线程，确保所有收集器线程完成并发回收
7. 并发引用更新: 与用户线程同步执行，进行引用更新操作
8. 最终引用更新: 到达检查点后，暂停所有用户线程，修正`GC Roots`中的引用
9. 并发清理: 与用户线程同步执行，清理回收的`Region`空间

优点:
- 需要暂停用户线程的时间极短
- 并发执行标记及清理过程
- 可指定最大停顿时间
- 不会产生内存碎片

缺点:
- 内存占用较大
- 使用读屏障增加对象访问开销(只有一条指令，但对象访问频率极高以至于不可忽视)
- 只有`OpenJDK 12`及以上版本支持

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`OpenJDK 12`及以上版本

## ZGC
Z Garbage Collector，与`JDK11`开始支持。

流程:
1. 并发标记
   1. 初始标记: 到达检查点后，暂停所有用户线程，单线程标记所有`GC Roots`直接关联的对象，并修改`TAMS`指针的值
   2. 并发标记: 与用户线程同步执行，从初始标记得到的对象进行遍历，及处理`SATB`记录下的引用变动对象
   3. 最终标记: 到达检查点后，暂停所有用户线程，多线程处理并发标记结束后遗留的少量`SATB`记录下的引用变动对象
2. 并发预备重分配: 统计需要清理的`Region`，将其组成重分配集(`Relocation Set`)。处理类卸载及弱引用
3. 并发重分配: 将重分配集中的存活对象复制到新`Region`上。并维护转发表。当用户线程访问该对象时，根据转发表访问到新复制到的对象上，并更新指针
4. 并发重映射: 修正整个堆中指向旧对象的引用，当所有指针修复完成后，释放转发表。该阶段可合并至下次GC中的并发标记阶段

与`G1`区别:
1. 不分代
2. `Region`大小不固定，分为: 小型(`2MB`, 放置小于`256KB`的对象)、中型(`32MB`, 放置`256KB`~`4MB`的对象)、大型(`2MB`的整数倍，放置大于`4MB`的对象，且每个`Region`仅放置一个)
3. 不使用记忆集
4. 使用染色指针+读屏障实现并发整理

染色指针:
- 将指针的前4位用于存储GC信息，即三色标记状态、是否进入重分配集(是否被移动)、是否只能通过`finalize()`方法才能访问。

流程:
1. 并发标记
    1. 初始标记: 到达检查点后，暂停所有用户线程，单线程标记所有`GC Roots`直接关联的对象，并修改`TAMS`指针的值
    2. 并发标记: 与用户线程同步执行，从初始标记得到的对象进行遍历，及处理`SATB`记录下的引用变动对象
    3. 最终标记: 到达检查点后，暂停所有用户线程，多线程处理并发标记结束后遗留的少量`SATB`记录下的引用变动对象
2. 并发预备重分配: 统计需要清理的`Region`，将其组成重分配集(`Relocation Set`)。处理类卸载及弱引用
3. 并发重分配: 将重分配集中的存活对象复制到新`Region`上。并维护转发表。当用户线程访问该对象时，根据转发表访问到新复制到的对象上，并更新指针
4. 并发重映射: 修正整个堆中指向旧对象的引用，当所有指针修复完成后，释放转发表。该阶段可合并至下次GC中的并发标记阶段

优点:
- 需要暂停用户线程的时间极短
- 吞吐量大

缺点:
- 仅支持`Linux 64位`系统
- 使用`JDK 11`及以上版本
- 管理内存小于`4TB`
- 对象分配速率不能太高

应用场景:
- 大内存场景(大于6GB内存，最好大于8GB)
- 使用`JDK 11`及以上版本+`Linux 64位`系统

# 其他
## Epsilon
不进行垃圾回收的垃圾收集器，仅进行分配，内存分配完成后结束进程。

优点:
- 运行负载极低

缺点:
- 无法进行垃圾回收

应用场景
- 运行时长极短的程序(如执行脚本)